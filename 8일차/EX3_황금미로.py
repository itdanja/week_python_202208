"""
    황금 미로 문제
        [조건]
            1. 왼쪽 상단[시작 행/열 ] 출발해서 오른쪽 하단[마지막행,마지막열]
            2. 시작부터 출구까지 지나가면서 최대 얻을수 있는 황금 개수 세기
            3. 대각선 이동불가
        [미로]

            --->  입구      1개    4개   4개   2개   2개
                                  1개    3개   3개   0개   5개
                                  1개    2개   4개   3개   0개
                                  3개    3개   0개   4개   2개
                                  1개    3개   4개   5개   3개  ----> 출구
"""

def printMaze( arr ) : # # 2차원의 메모이제이션 출력 함수
        for row in range( ROW ) :
                for col in range( COL ) :
                       print( "%3s"  % arr[row][col] ,  end = ' ' )
                print()
        print()

def solution() :
        # 1. 2차원의 메모이제이션 -> 미로[5x5] 칸 동일
        memo = [ [ 0 for _ in range( COL ) ]  for _ in range(ROW) ]

        # 2. 입구에 있는 황금의 무조건 획득
        memo[0][0] = goldMaze[0][0]             # 미로에 [0][0] 존재하는 황금을 메모에 대입

        ###################
        # 3-1 가로의 누적합계
        rowsum = memo[0][0]                             # 1. 첫번째 값을 누적변수에 넣는다.
        for i in range( 1 , ROW ) :                            # 2. 두번째 행부터 마지막 행까지 반복
                rowsum += goldMaze[0][i]                       # 3. 미로에 있는 [0][i]번째 골드 누적 더하기
                memo[0][i] = rowsum                                     # 4. 메모에 누적 골드 대입

        # 3-2 세로의 누적합계
        colsum = memo[0][0]
        for i in range( 1 , COL ):
                colsum += goldMaze[i][0]
                memo[i][0] = colsum

        # 4. * 행/열 비교[ 현재위치에서 아래 값과 오른쪽 값 비교 하기 ]

        for row in range( 1 , ROW ) :           #  행 : 1부터(3-1에서 구했기 때문에 ) 4까지 반복
                for col in range( 1 , COL ):            # 열 : 1부터(3-2에서 구했기 때문에) 4까지 반복

                        if memo[row][col-1] > memo[row-1][col] :  # 아래 방향이 더 크면
                                memo[row][col] = memo[row][col-1] + goldMaze[row][col]  # 아래방향 골드 + 기존 골드
                        else :     # 오른쪽이 더 크면
                                memo[row][col] = memo[row-1][col] + goldMaze[row][col]  # 오른쪽방향 골드 + 기존 골드

        # 2차원의 메모이제이션 출력
        print("------------ 메모이제이션 출력 ------------")
        printMaze( memo )

        # 5. 지나온 경로 출력
        print('------------ 지나온 경로 출력 ---------------')
        row = ROW-1             # 마지막 행 인덱스
        col = COL-1                     # 마지막 열 인덱스

        count = 0               # 최대 황금 개수
        if memo[row-1][col] > memo[row][col-1]  : # 출구기준 위쪽데이터와 왼쪽데이터
                count = memo[row-1][col]
        else:
                count = memo[row][col-1]

        memo[row][col] = '*'    # 마지막 칸에 * 출력

        while row !=0 or col != 0 :          # 행이 0이 아니 거나 열이 0이 아닐때 반복 [ row 와 col 0 이 종료 ]
                if row -1 >= 0 and col-1>= 0 :
                        if memo[row-1][col] > memo[row][col-1] :
                                # 위쪽 방향이 더 크면  -> 오른쪽 경로
                                row -= 1
                                # 위로 이동
                        else:
                                # 왼쪽  방향이 더 크면  -> 아래쪽 경로
                                col -= 1
                                # 왼쪽 이동
                elif row-1 < 0 and col-1 >= 0 : # 만약에 위쪽 방향에 인덱스가 0보다 작으면
                        col -= 1        # 왼쪽 방향
                else: # 만약에 왼쪽 방향에 인덱스가 0보다 작으면
                        row -= 1
                memo[row][col] = '*'
        print("------------ 메모이제이션 출력 ------------")
        printMaze(memo)

        return count

ROW , COL = 5 , 5 # 미로 칸수
goldMaze = [
        [ 1 , 4 , 4 , 2 , 2],
        [ 1 , 3 , 3 , 0 , 5],
        [ 1 , 2 , 4 , 3 , 0],
        [ 3 , 3 , 0 , 4 , 2],
        [ 1 , 3 , 4 , 5 , 3],
]
print(' 최대 황금 미로 에서 얻을 수 있는 황금 개수 : ' , solution() )


"""
        순서도 [ 알고리즘 ] 
                1. 메모이제이션[ 2차원리스트 ] 사용 : 미로[5X5] 의 개수만큼
                         0 , 0 , 0 , 0 , 0
                         0 , 0 , 0 , 0 , 0
                         0 , 0 , 0 , 0 , 0
                         0 , 0 , 0 , 0 , 0 
                         0 , 0 , 0 , 0 , 0
                2. 입구에 있는 골드 무조건 획득
                         1 , 0 , 0 , 0 , 0
                         0 , 0 , 0 , 0 , 0
                         0 , 0 , 0 , 0 , 0
                         0 , 0 , 0 , 0 , 0 
                         0 , 0 , 0 , 0 , 0
                3. 첫행,첫열은 누적합계[ 무조건 오른쪽 이동 하는 경우의수 / 무조건 아래로 이동 내려가는 경우의 수 ]
                        3-1 첫행의 누적합계 [ 무조건 오른쪽 이동 하는 경우의수 ] 
                                1 , 5 , 9 , 11 , 13
                                 0 , 0 , 0 , 0 , 0
                                 0 , 0 , 0 , 0 , 0
                                 0 , 0 , 0 , 0 , 0 
                                 0 , 0 , 0 , 0 , 0
                        3-2 첫열의 누적합꼐 [ 무조건 아래로 이동 내려가는 경우의 수 ]
                                1 , 5 , 9 , 11 , 13
                                 2 , 0 , 0 , 0 , 0
                                 3 , 0 , 0 , 0 , 0
                                 6 , 0 , 0 , 0 , 0 
                                 7 , 0 , 0 , 0 , 0
                                 
                4.  메모이제이션에 총 누적합계 
                        * 만약에 위에 값이 더 크면 기존+위
                        * 만약에 왼쪽 값이 더 크면 기존+왼
                        row = 1 
                                col = 1         [1][3] : 3 =>  왼:2 < 위:5        5+3 -> 8
                                col = 2         [1][2] : 3 =>  왼:8 < 위:9        9+3 -> 12          
                                col = 3         [1][3] : 0 =>  왼:12 < 위:11      0 -> 12 
                                col = 4         [1][4] : 5 =>  왼:12 < 위:13      13+5 -> 18
                                 1 , 5 , 9 , 11 , 13
                                 2 , 8 , 12 , 12 , 18
                                 3 , 0 , 0 , 0 , 0
                                 6 , 0 , 0 , 0 , 0 
                                 7 , 0 , 0 , 0 , 0
                                 
                        row = 2 
                                col = 1         [2][1] : 2 => 왼1 < 위:8          8+2 ->  10
                                col = 2         [2][2] : 4 => 왼10 < 위12       12+4 -> 16
                                col = 3         [2][3] : 3 => 왼16 < 위 12      16+3 -> 19 
                                col = 4         [2][4] : 0 => 왼19 < 위 18       19+0 -> 19
                                
                                1 , 5 , 9 , 11 , 13
                                 2 , 8 , 12 , 12 , 18
                                 3 , 10 ,16 , 19 , 19
                                 6 , 0 , 0 , 0 , 0 
                                 7 , 0 , 0 , 0 , 0
                                
                        row = 3
                                col = 1
                                col = 2
                                col = 3
                                col = 4
                        row = 4
                                col = 1
                                col = 2
                                col = 3
                                col = 4
                                
                                  1   5   9  11  13 
                                  2   8  12  12  18 
                                  3  10  16  19  19 
                                  6  13  16  23  25 
                                  7  16  20  28  31 
                5. 지나온 경로 출력 
                        1. 출구는 * 출력 
                                  1   5   9  11  13 
                                  2   8  12  12  18 
                                  3  10  16  19  19 
                                  6  13  16  23  25 
                                  7  16  20  28   *
                                  
                6. 출구에서 부터 입구까지 반복문 
                        
                        row = 4 col = 4
                         if memo[row-1][col] > memo[row][col-1] :
                                 1   5   9  11  13 
                                  2   8  12  12  18 
                                  3  10  16  19  19 
                                  6  13  16  23   *
                                  7  16  20  28   *
                        if memo[row-1][col] > memo[row][col-1] :
                                 1   5   9  11  13 
                                  2   8  12  12  18 
                                  3  10  16  19  19 
                                  6  13  16   *    *
                                  7  16  20  28   *
                        if memo[row-1][col] > memo[row][col-1] :
                                 1   5   9  11  13 
                                  2   8  12  12  18 
                                  3  10  16  *    19 
                                  6  13  16   *    *
                                  7  16  20  28   *
                        if memo[row-1][col] > memo[row][col-1] :
                                 1   5   9  11  13 
                                  2   8  12  12  18 
                                  3  10  *     *    19 
                                  6  13  16   *    *
                                  7  16  20  28   *
                        if memo[row-1][col] > memo[row][col-1] :
                                 1   5   9  11  13 
                                  2   8  *  12  18 
                                  3  10  *     *    19 
                                  6  13  16   *    *
                                  7  16  20  28   *
                        if memo[row-1][col] > memo[row][col-1] :
                                 1   5   *  11  13 
                                  2   8  *  12  18 
                                  3  10  *     *    19 
                                  6  13  16   *    *
                                  7  16  20  28   *
                         elif row-1 < 0 and col-1 >= 0 : 
                                 1   *   *  11  13 
                                  2   8  *  12  18 
                                  3  10  *     *    19 
                                  6  13  16   *    *
                                  7  16  20  28   *
                        elif row-1 < 0 and col-1 >= 0 : 
                                 *   *   *  11  13 
                                  2   8  *  12  18 
                                  3  10  *     *    19 
                                  6  13  16   *    *
                                  7  16  20  28   *
"""

























